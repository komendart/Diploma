\subsection{Определения и постановка задачи}

Хорошо изучена похожая задача нахождения статически оптимального дерева поиска.

Постановка этой задачи такова: есть множество из $n$ различных упорядоченных элементов и вероятности:

\begin{itemize}
    \item $A_1,\dots,A_n$, что запрос будет с значением, равным соответствующему элементу множества
    \item $B_0,\dots,B_n$, что запрос будет лежать до первого элемента, либо между двумя элементами, либо после последнего
\end{itemize}
  
Необходимо найти дерево поиска на данном множестве такое, что среднее количество посещенных вершин при запросах будет минимально.

Дерево поиска - это двоичное дерево такое, что

\begin{itemize}
    \item Есть $n$ вершин, в которых стоят различные значения из данного множества
    \item Если в вершине стоит число $x$, то у всех вершин в её левом поддереве значения меньше чем $x$, в правом поддереве больше чем $x$
\end{itemize}
  
Запрос к дереву поиска выглядит таким образом. Он начинается в корне. Если число из запроса меньше, чем число в текущей вершине, то переходим в её левого сына. Если больше, то в правого. Иначе, а также если мы попытались пойти в несуществующую вершину, запрос завершается.

\subsection{Решения}

В статье \cite{knuth71} было получено точное решение за $O(n^2)$ времени и памяти.

Идея такова - можно найти $dp_{L, R}$ - оптимальное среднее количество посещенных вершин, если дерево построено на значениях с $L$ по $R - 1$. Например, для случая нулевых $B_i$ верно, что

\begin{itemize}
    \item $dp_{L, L} = 0$
    \item $dp_{L, R} = A_L + \dots + A_{R - 1} + \min \limits_{L \leqslant m < R} {dp_{L, m} + dp_{m + 1, R}}$
\end{itemize}
  
Это верно, так как на каждом шаге выбирается элемент в корне поддерева, а затем задачу можно свести к задачам для левого и правого поддерева. При этом каждый запрос пройдёт через корень поддерева и его вероятность нужно прибавить.
  
Так как $dp_{L, R}$ зависит только от значений $dp$ для меньших по длине отрезков, то если перебирать отрезки по неубыванию, $dp_{L, R}$ можно найти за $O(n^3)$ времени. Дальше в статье доказывалось, что в данном случае можно оптимизировать решение до $O(n^2)$ времени.

В статье \cite{mehlhorn1975} было получено приближенное решение за $O(n)$ времени. Идея такова - на каждом шаге выбирать такое значение в корне поддерева, что суммы вероятностей запросов в подзадачах для левого и правого поддерева как можно более близки друг к другу, после этого рекурсивно запустить решение для поддеревьев.

Было показано, что $0.63H \leqslant P_{opt} \leqslant P_{approx} \leqslant 2 + 1.44H$, где $H$ - энтропия распределения вероятностей, $P_{opt}$ - среднее количество посещенных вершин в оптимальном решении, $P_{approx}$ - в приближенном. Таким образом, приближенное решение не хуже оптимального более чем в константу раз, где константу можно оценить сверху как $2.29$

В статье \cite{garsia1977} было приведено точное решение за $O(n \log n)$ времени для важного случая, когда вероятности $A_i$ равны нулю.

В статье \cite{yao1980} было приведено обобщение того, когда точные решения за $O(n^3)$ времени могут быть соптимизированы до $O(n^2)$